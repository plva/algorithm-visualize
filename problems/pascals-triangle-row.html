<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pascal's Triangle Visualizer</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    #controls { margin-bottom: 12px; }
    input { width: 60px; padding: 4px; }
    button { margin-left: 6px; padding: 4px 8px; }

    /* Current row display */
    #rowContainer { display: flex; gap: 8px; margin-top: 20px; flex-wrap: wrap; }
    .cell {
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid #aaa;
      border-radius: 4px;
      transition: background 0.2s;
    }
    .highlightA { background: gold; }
    .highlightB { background: lightgreen; }

    #msg { margin-top: 12px; font-weight: bold; min-height: 24px; }

    /* Triangle display */
    #triangleContainer { margin-top: 32px; }
    .triangle-row { display: flex; justify-content: center; gap: 8px; margin: 4px 0; }
    .triangle-cell { 
      min-width: 32px; 
      padding: 4px 6px; 
      border: 1px solid #aaa; 
      border-radius: 3px; 
      text-align: center;
      transition: background-color 0.3s ease;
    }
    /* Color distinction */
    .triangle-row.past   .triangle-cell { background: #f7f7f7; }
    .triangle-row.active .triangle-cell { background: #d0f0ff; }

    pre { background: #f7f7f7; padding: 12px; border-radius: 4px; border: 1px solid #ddd; overflow-x: auto; }
  </style>
</head>
<body>
<h2>Pascal's Triangle Row Visualizer</h2>

<div id="controls">
  Row index: <input type="number" id="rowInput" value="6" min="0" />
  <button id="generateBtn">Generate Steps</button>
  <button id="nextBtn" disabled>Next Step</button>
  <button id="autoBtn" disabled>Auto&nbsp;Play</button>
</div>

<div id="rowContainer"></div>
<div id="msg"></div>
<hr/>
<h3>Triangle so far</h3>
<div id="triangleContainer"></div>

<hr/>
<h3>Algorithm used (JavaScript)</h3>
<pre id="codeBlock"></pre>

<script>
const rowContainer       = document.getElementById('rowContainer');
const triangleContainer  = document.getElementById('triangleContainer');
const msg                = document.getElementById('msg');
const nextBtn            = document.getElementById('nextBtn');
const autoBtn            = document.getElementById('autoBtn');
const generateBtn        = document.getElementById('generateBtn');
const rowInput           = document.getElementById('rowInput');
const codeBlock          = document.getElementById('codeBlock');

/* ================= Algorithm displayed ================= */
codeBlock.textContent = `function getPascalRow(k) {
  let row = [1];
  for (let i = 1; i <= k; i++) {
    row.push(1);
    for (let j = row.length - 2; j > 0; j--) {
      row[j] = row[j] + row[j - 1];
    }
  }
  return row;
}`;
/* ====================================================== */

let steps = [];        // array of step objects
let currRow = [];      // underlying array we mutate
let stepPtr = 0;       // index of next step to execute
let autoTimer = null;  // interval handle for autoplay
let lastRowDiv = null; // reference to last (active) triangle row div
let maxValue = 1;      // track the maximum value seen so far for heatmap

function getHeatmapColor(value, maxVal) {
  if (maxVal <= 1) return '#ffffff'; // white for base case
  
  const ratio = value / maxVal;
  // Simple white to green gradient
  const greenIntensity = Math.floor(255 * ratio);
  return `rgb(255, ${255 - greenIntensity}, 255)`;
}

function renderRow(arr, idxA = -1, idxB = -1) {
  rowContainer.innerHTML = '';
  arr.forEach((v, idx) => {
    const div = document.createElement('div');
    div.className = 'cell';
    if (idx === idxA) div.classList.add('highlightA');
    if (idx === idxB) div.classList.add('highlightB');
    div.textContent = v;
    rowContainer.appendChild(div);
  });
}

function addTriangleRow(arr, isActive) {
  // downgrade previous active row to past
  if (isActive && lastRowDiv) {
    lastRowDiv.classList.remove('active');
    lastRowDiv.classList.add('past');
  }

  const rowDiv = document.createElement('div');
  rowDiv.className = 'triangle-row ' + (isActive ? 'active' : 'past');
  arr.forEach(v => {
    const c = document.createElement('div');
    c.className = 'triangle-cell';
    c.textContent = v;
    // Only apply heatmap color to the active (latest) row
    if (isActive) {
      c.style.backgroundColor = getHeatmapColor(v, maxValue);
    }
    rowDiv.appendChild(c);
  });
  triangleContainer.appendChild(rowDiv);

  if (isActive) lastRowDiv = rowDiv;
}

function updateLatestRowHeatmap() {
  // Only update the latest (active) row with new heatmap colors
  if (lastRowDiv) {
    const cells = lastRowDiv.querySelectorAll('.triangle-cell');
    cells.forEach(cell => {
      const value = parseInt(cell.textContent);
      cell.style.backgroundColor = getHeatmapColor(value, maxValue);
    });
  }
}

// Build the list of steps, capturing rowSize per step
function buildSteps(target) {
  triangleContainer.innerHTML = '';
  rowContainer.innerHTML      = '';
  msg.textContent             = '';
  steps        = [];
  currRow      = [1];
  lastRowDiv   = null;
  maxValue     = 1;           // reset max value
  addTriangleRow([1], false);               // base row is past immediately

  for (let r = 1; r <= target; r++) {
    currRow.push(1);                        // append trailing 1 (row size now r+1)
    const size = r + 1;

    for (let j = size - 2; j > 0; j--) {
      steps.push({ idx: j, rowSize: size });
    }
    steps.push({ rowDone: true, rowNum: r, rowSize: size });
  }
}

function nextStep() {
  if (stepPtr >= steps.length) {
    finishPlayback();
    return;
  }

  const step = steps[stepPtr++];

  if (step.rowDone) {
    renderRow(currRow.slice(0, step.rowSize));
    addTriangleRow(currRow.slice(0, step.rowSize), true); // mark as active
    msg.textContent = `Completed row ${step.rowNum}`;
    return;
  }

  const { idx: j, rowSize } = step;

  // Preâ€‘update highlight
  renderRow(currRow.slice(0, rowSize), j - 1, j);
  const newVal = currRow[j] + currRow[j - 1];
  msg.textContent = `row[${j}] = ${currRow[j]} + ${currRow[j - 1]} = ${newVal}`;

  // Perform update after a short delay so highlight is visible
  setTimeout(() => {
    currRow[j] = newVal;
    
    // Update max value if necessary
    if (newVal > maxValue) {
      maxValue = newVal;
      updateLatestRowHeatmap();
    }
    
    renderRow(currRow.slice(0, rowSize), -1, j); // highlight updated cell in green
    msg.textContent = `row[${j}] updated to ${newVal}`;
  }, 200);
}

function finishPlayback() {
  nextBtn.disabled = true;
  autoBtn.disabled = true;
  msg.textContent = 'Finished!';
  if (autoTimer) {
    clearInterval(autoTimer);
    autoTimer = null;
  }
}

function startAutoplay() {
  if (autoTimer) return; // already playing
  nextBtn.disabled = true;
  autoBtn.disabled = true;
  autoTimer = setInterval(() => {
    nextStep();
    if (stepPtr >= steps.length) {
      finishPlayback();
    }
  }, 333); // 3 steps per second
}

// Event wiring

generateBtn.addEventListener('click', () => {
  const idx = Math.max(0, parseInt(rowInput.value, 10) || 0);

  // stop any existing autoplay
  if (autoTimer) {
    clearInterval(autoTimer);
    autoTimer = null;
  }

  stepPtr = 0;
  buildSteps(idx);
  renderRow([1]);
  msg.textContent   = 'Generated steps. Click "Next Step" or "Auto Play" to begin.';
  nextBtn.disabled  = false;
  autoBtn.disabled  = false;
});

nextBtn.addEventListener('click', nextStep);
autoBtn.addEventListener('click', startAutoplay);
</script>
</body>
</html>
